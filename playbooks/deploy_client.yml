---
# Dynamically populate groups from persisted results from previous playbooks.
- hosts:
   localhost
  gather_facts: no
  tasks:

    - shell: "cat ~/vars/f5aws/env/{{ env_name }}/{{ item }}.json"
      register: output
      with_items: groups['clienthost-managers']
      delegate_to: localhost

    - add_host: group=clienthosts
        name="{{ item.stdout | from_json | attr('get')('ClientInstancePublicIp') }}"
        ClientInstancePublicIp="{{ item.stdout | from_json | attr('get')('ClientInstancePublicIp') }}"
        ClientInstancePrivateIp="{{ item.stdout | from_json | attr('get')('ClientInstancePrivateIp') }}"
        ansible_ssh_user="ubuntu"
      with_items: output['results']

# Need to wait for port 22 to open up
- hosts: clienthosts
  gather_facts: False
  tasks:
    - local_action: wait_for host={{ inventory_hostname }} search_regex=OpenSSH delay=10 port=22
  sudo: false

# Now launch containers inside them
# Amazon amis we're using already have docker installed so no need for install_docker role
- hosts: clienthosts
  gather_facts: False
  vars:
    ansible_sudo: True
  roles:
    # - jumpbox
    - client

# Modify Jmeter Scripts to hit vips or wideips
# Means replacing hostnames with BIGIP-VIPs jmeter files themselves (No DNS requirement)

#ex.
#    - replace: dest=~/simple-load-generation.jmx regexp='demo.example.com' replace='{{VIP}}'
# OR
# modify /etc/resolv.conf to resolve example.com at GTM Listener
# so first need to load GTM listeners again (Vip1)

- hosts: localhost
  vars:
    vip_id: "Vip1"
  gather_facts: no
  tasks:
    - shell: "cat ~/vars/f5aws/env/{{ env_name }}/{{ item }}.json"
      register: output
      with_items: groups['gtm-managers']

    - add_host: group=gtms name="{{ item.stdout | from_json | attr('get')('ManagementInterfacePublicIp') }}"
        ExternalInterfacePublicIp="{{ item.stdout | from_json | attr('get')('ExternalInterfacePublicIp') }}"
        ExternalInterfacePrivateIp="{{ item.stdout | from_json | attr('get')('ExternalInterfacePrivateIp') }}"
        InternalInterfacePrivateIp="{{ item.stdout | from_json | attr('get')('InternalInterfacePrivateIp') }}"
        VipAddress="{{ item.stdout | from_json | attr('get')('Vip1') }}"
        ansible_ssh_user="admin"
      with_items: output['results']

    - debug: var=groups['gtms']

### Example Default /etc/resolv.conf in AWS ####

# ubuntu@ip-172-16-13-4:~$ cat /etc/resolv.conf
# # Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)
# #     DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
# nameserver 172.16.0.2
# search ec2.internal
#

# Modify Nameservers 
- hosts: clienthosts
  gather_facts: False
  vars:
    ansible_sudo: True
  tasks:
    - name: Grab number of existing name servers
      shell: "egrep -c nameserver /etc/resolv.conf"
      ignore_errors: true
      register: nameserver_count

    #- debug: var=nameserver_count.stdout

    # Need to place GTMs first. 
    - name: Add example.com nameservers to /etc/resolv.conf if just default one nameserver
      shell: "echo 'nameserver {{hostvars[item]['VipAddress']}}' >> /etc/resolvconf/resolv.conf.d/head"
      #shell: "echo $(echo 'nameserver {{hostvars[item]['VipAddress']}}\n' | cat - /etc/resolv.conf ) >> /etc/resolv.conf"
      with_items: groups['gtms'] 
      when: nameserver_count.stdout|int < 2

    #Restart resolvconf to pickup changes
    - name: restart resolvconf
      shell: resolvconf -u 

# Upload Jmeter scripts
- hosts: clienthosts
  gather_facts: False
  tasks:

    - name: Copy over simple load generation jmeter script
      copy: src=../roles/client/files/simple-load-generation.jmx dest=~/

    - name: Copy over attack jmeter script
      copy: src=../roles/client/files/attack-site.jmx dest=~/
