---
# Attach an EIP to the GTM Listener
# This is not quite a normal VIP like we provision an EIP on a per-app basis in LTM 
# GTM CFT should probably just create 2 EIPs automatically. 
# 1 for the Self-IP (currently done in CFT)
# 1 for GTM Listener VIP

- hosts: gtm-managers
  gather_facts: no
  vars:
    vip_id: "Vip1"
  #Grab Interface IDs and Secondary IPs from each BIGIP
  vars_files:
     - "~/vars/f5aws/env/{{ env_name }}/{{ inventory_hostname }}.yml"
  tasks:
    - name: deploy eips
      include: "{{ install_path }}/roles/infra/tasks/deploy_eip.yml"

# Dynamically populate groups from persisted results from previous playbooks.
# This is a bit more complicated than the rest of our dynamic group 
#  population because there may or may not be GTMs deployed, based
#  on the topology.  In the case that there are no members in the gtm-managers
#  group, we need to make sure that ansible fails nicely. 
- hosts:
   localhost
  gather_facts: no
  tasks:
    - set_fact: list=groups['gtm-managers']
      when: groups | attr('get')('gtm-managers','') != ''
    - set_fact: list=[]
      when: groups | attr('get')('gtm-managers','') == ''
    - name: load the gtm_cft results
      shell: "cat ~/vars/f5aws/env/{{ env_name }}/{{ item }}.json" #gtm
      register: output
      with_items: list
      ignore_errors: true
    - add_host: group=gtms
        name="{{ item.stdout | from_json | attr('get')('ManagementInterfacePublicIp') }}"
        ManagementInterfacePublicIp="{{ item.stdout | from_json | attr('get')('ManagementInterfacePublicIp') }}"
        ManagementInterfacePrivateIp="{{ item.stdout | from_json | attr('get')('ManagementInterfacePrivateIp') }}"
        ExternalInterfacePublicIp="{{ item.stdout | from_json | attr('get')('ExternalInterfacePublicIp') }}"
        ExternalInterfacePrivateIp="{{ item.stdout | from_json | attr('get')('ExternalInterfacePrivateIp') }}"
        VipAddress="{{ item.stdout | from_json | attr('get')('Vip1') }}"
        region="{{region}}"
      with_items: list
      when: output|success

    # bigips host group
    - shell: "cat ~/vars/f5aws/env/{{ env_name }}/{{ item }}.json"
      register: output
      with_items: groups['bigip-managers']
      delegate_to: localhost
    - add_host: group=bigips
        name="{{ item.stdout | from_json | attr('get')('ManagementInterfacePublicIp') }}"
        ManagementInterfacePrivateIp="{{ item.stdout | from_json | attr('get')('ManagementInterfacePrivateIp') }}"
        ExternalInterfacePublicIp="{{ item.stdout | from_json | attr('get')('ExternalInterfacePublicIp') }}"
        ExternalInterfacePrivateIp="{{ item.stdout | from_json | attr('get')('ExternalInterfacePrivateIp') }}"
        region="{{region}}"
      with_items: output['results']

# Wait for hosts to become ready
- hosts: gtms
  gather_facts: False
  sudo: false
  tasks:
    - name:  Wait for ssh port to open
      local_action: wait_for host={{ inventory_hostname }} search_regex=OpenSSH delay=10 port=22
    - name: Wait until BIG-IP is ready for provisioning
      raw: "run /util bash -c 'cat /var/prompt/ps1'"
      until: (result.stdout.find("Active") != -1)
      register: result
      retries: 40

# Basic device setup using tmsh to enable further provisioning
- hosts: gtms
  gather_facts: no
  roles:
    # adds users via tmsh
    - bigip_base 
    # adds json so ansible doesn't puke
    #- bigip_jsonify
    # provisions system globals like ntp, dns, snmp, syslog, db keys  
    - bigip_system
    # sets AWS keys and disables DHCP
    - bigip_system_aws
    # sets vlans, self-ips, routes
    - gtm_network
    # provisions GTM 
    - gtm_system
    # setup gtm configuration for this network topology
    - gtm_conf
    # setup up gtms in cluster, they share route information
    - gtm_cluster
