#!/usr/bin/env python

"""

Chris Mutzel <c.mutzel@f5.com>
Alex Applebaum <a.applebaum@f5.com>

For more information on usage see README.md

"""

# python built-ins
import os
import sys
import json
import argparse

# some path mudgery
# Augment PYTHONPATH to find Python modules relative to this file path
# This is so that we can find the modules when running from a local checkout
# installed as editable with `pip install -e ...` or `python setup.py develop`
local_ansible_path = os.path.abspath(
  os.path.join(os.path.dirname(__file__), '..', 'lib')
)
local_module_path = os.path.abspath(
  os.path.join(os.path.dirname(__file__), '..', 'src')
)

sys.path.append(local_module_path)
sys.path.append(local_ansible_path)

#import f5_aws.config as config
from f5_aws.config import Config
from f5_aws.runner import EnvironmentManager
from f5_aws.exceptions import ValidationError, ExecutionError, LifecycleError

# ansible stuff
import ansible.playbook
from ansible import errors
from ansible import utils
from ansible.callbacks import display
from ansible.color import ANSIBLE_COLOR, stringc


config = Config().config

LOCK_TIMEOUT = 10  # seconds

def print_playbook_results(exec_results):
  if 'playbook_results' in exec_results:
    exec_results['playbook_results'].print_playbook_results()
    
def cli_init(args): 
  """
    Create the ansible inventory for the environment
      based on the deployment model and other variables
  """  
  exec_results = EnvironmentManager(args).init()
  print_playbook_results(exec_results)

  if ('playbook_results' in exec_results and 
    getattr(exec_results['playbook_results'], 'statuscode', -1)) == 0:
    print ''
    print 'The Ansible inventory for your environment has not been initialized. \
Deploy the environment with the `deploy` command.'

def cli_deploy(args):
  """
    Deploy an environment based on the set of inventory files 
    created by the 'init' command.
  """
  exec_results = EnvironmentManager(args).deploy()
  print_playbook_results(exec_results)

  print ''
  print 'If you\'ve deployed a client, you can start traffic by \
running:\n./bin/{} {} {}'.format(
    config['prog'], 'start_traffic', args.env_name)

  print '\nYou can re-print the above login information along with the ansible \
inventory using "info" command\n'

def cli_teardown(exec_results):
  """
    Complete teardown of a deployed environment.
    Does not remove the environment inventory. 
  """
  exec_results = EnvironmentManager(args).teardown()
  print_playbook_results(exec_results)

def cli_remove(args):
  """
    Deletes all inventory files for a deployment from ~/vars/f5aws/env/<env name>
    This environment should already have been torn down using `teardown`
  """
  exec_results = EnvironmentManager(args).remove()
  print_playbook_results(exec_results)

def cli_list(exec_results):
  """
    Implements a command line method to list all environments that
    have been instantiated using `init`.
  """
  envs = EnvironmentManager.get_envs()
  if len(envs) == 0:
    display("(none)", color='red', stderr=False)
  else:
    for env in envs:
      EnvironmentManager(get_namespace(env_name=env)).display_basic_info()

def cli_inventory(args):
  print json.dumps(EnvironmentManager(get_namespace(env_name=args.env_name)).inventory(),
    indent=4, sort_keys=True)

def cli_resources(exec_results):
  """
    Implements command line method to provide more details on the resources associated with 
    a particular deployment (vpc, subnets, bigip, app hosts, etc...)
  """
  resources, statuses = EnvironmentManager(get_namespace(env_name=args.env_name)).resources()
  for r in resources:
    print r
    print json.dumps(statuses[r])
    
def cli_login(args):
  print json.dumps(EnvironmentManager(get_namespace(env_name=args.env_name)).login_info(),
    indent=4, sort_keys=True)


def cli_start_traffic(exec_results):
  """
    Implements command line method to pass traffic through BIG-IP
  """
  exec_results = EnvironmentManager(args).launch_traffic()
  print_playbook_results(exec_results)

def cli_stop_traffic(exec_results):
  """
    Implements command line method to stop traffic through BIG-IP
  """
  exec_results = EnvironmentManager(args).stop_traffic()
  print_playbook_results(exec_results)

def create_parser():
  """
    Define the various command line methods and arguments here. 
    For each command, implement a sub-parser. Later we will call
    the corrosponding method (e.g. init -> cli_init) and pass the 
    corrosponding argument values. 
  """
  parser = argparse.ArgumentParser(prog=config['prog'])
  parser.add_argument('-v', '--verbose', action='count', default=0,
            help='verbose mode (-vvv for more, -vvvv to enable connection debugging')
  subparsers = parser.add_subparsers(dest='cmd', help='sub-command help')

  parser_init = subparsers.add_parser('init',
                    help='Create a new AWS deployment with F5 services.')
  parser_init.set_defaults(cmd='init')
  parser_init.add_argument('env_name',
               help='Name of the new environment to be created')
  parser_init.add_argument('-f', '--force', required=False,
               action='store_true', default=False,
               help="Use to update inventory variables for an existing environment")
  parser_init.add_argument('-e', '--extra-vars', required=True,
               dest="extra_vars", action="append",
               help="set additional variables as key=value or YAML/JSON", default=[])
  parser_deploy = subparsers.add_parser('deploy',
                      help='Deploy EC2 resource and application services based on inventory files created using `init`.')
  parser_deploy.add_argument('env_name', metavar='ENVIRONMENT',
                 type=str, help='Name of environment to be deployed/updated')

  parser_teardown = subparsers.add_parser('teardown',
                      help='De-provision all resources in AWS EC2 for an environment created using `init`.')
  parser_teardown.add_argument('env_name', metavar='ENVIRONMENT',
                 type=str, help='Name of environment to be de-provisioned. ')

  parser_list = subparsers.add_parser('list',
                    help='List all deployments and corrosponding resource statuses.')

  parser_remove = subparsers.add_parser('remove',
                      help='Remove all inventory files for an environment created using `init`.')
  parser_remove.add_argument('env_name', metavar='ENVIRONMENT',
                 type=str, help='Name of environment to be deleted')

  parser_start_traffic = subparsers.add_parser('start_traffic',
                         help='Begins jmeter client on client in a single availability zone')
  parser_start_traffic.add_argument('env_name', metavar='ENVIRONMENT',
                    type=str, help='Name of environment to which jmeter client should run traffic')

  parser_stop_traffic = subparsers.add_parser('stop_traffic',
                        help='Stops jmeter client ')
  parser_stop_traffic.add_argument('env_name', metavar='ENVIRONMENT',
                   type=str, help='Name of environment')

  parser_info = subparsers.add_parser('info',
                    help='Show resource variables along with environment information.')

  # multiple subparsers for the info command
  info_subparsers = parser_info.add_subparsers(
    dest='cmd', help='sub-command help')

  parser_inventory = info_subparsers.add_parser('inventory',
                          help='Displays the ansible inventory associated with this environment. Dynamic inventory groups are not shown')
  parser_inventory.add_argument('env_name', metavar='ENVIRONMENT',
                  type=str, help='Name of environment')

  parser_resources = info_subparsers.add_parser('resources',
                          help='Shows hosts, associated resources and variables that are deployed via CloudFormation')
  parser_resources.add_argument('env_name', metavar='ENVIRONMENT',
                  type=str, help='Name of environment')

  parser_login = info_subparsers.add_parser('login',
                        help='Displays login information for deployed hosts (bigips, gtms, client, etc')
  parser_login.add_argument('env_name', metavar='ENVIRONMENT',
                type=str, help='Name of environment')

  return parser

# not sure how else to generate a 'namespace' like object
#  similar to what argparse returns...couldn't they just use a dict?
def get_namespace(**kwargs):
  class Namespace(object):
    def __init__(self, kwargs):
      for k, v in kwargs.items():
        setattr(self, k, v)
  return Namespace(kwargs)

if __name__ == "__main__":
  display(" ", log_only=True)
  display(" ".join(sys.argv), log_only=True)
  display(" ", log_only=True)

  try:
    parser = create_parser()
    args = parser.parse_args()

    for i in range(args.verbose):
      print 'Incrementing debug to level %s' % i
      utils.increment_debug(False, False, False, False)

    handlers = {
      'init': cli_init,
      'list': cli_list,
      'deploy': cli_deploy,
      'login': cli_login,
      'resources': cli_resources,
      'inventory': cli_inventory,
      'start_traffic': cli_start_traffic,
      'stop_traffic': cli_stop_traffic,
      'remove': cli_remove,
      'teardown': cli_teardown,
    }

    handlers[args.cmd](args)

  except ValidationError, e:
    display("INPUT ERROR: %s" % e, color='red', stderr=True)
  except ExecutionError, e:
    display("RUNTIME ERROR: %s" % e, color='red', stderr=True)
  except LifecycleError, e:
    display("LIFECYCLE ERROR: %s" % e, color='red', stderr=True)
  except errors.AnsibleError, e:
    display("ANSIBLE ERROR: %s" % e, color='red', stderr=True)
    sys.exit(1)
  except KeyboardInterrupt, ke:
    display("ERROR: interrupted", color='red', stderr=True)
    sys.exit(1)
  except Exception, e:
    display("ERROR: %s" % e, color='red', stderr=True)
    sys.exit(1)


